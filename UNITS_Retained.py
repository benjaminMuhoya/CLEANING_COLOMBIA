#!/usr/bin/env python3
import re
import pandas as pd
import numpy as np

#load data Generated by Previous Impute_PH_URINE.py script 
df = pd.read_csv("META_updated_FINAL_COLOMBIA.csv")

# Flag metadata so that everything else treated as biomarker
METADATA_COLS = [
    "unique_colombia","Unique.ID","age","collected_on","file_name","gender","lab_no","mrn",
    "name","received_on","referred_by","reported_on","merge_key","Sex","Age","Sampling.location"
]

# If some of these aren’t present, that’s fine.
present_meta = [c for c in METADATA_COLS if c in df.columns]
biomarker_cols = [c for c in df.columns if c not in present_meta]

# helpers to seperate the values and units surgically .Dr Muhoya style

num_regex = re.compile(r"""
    ^\s*                # leading spaces
    (?P<num>[+-]?\d{1,3}(?:,\d{3})*|\d+)   # int with optional thousands
    (?:\.\d+)?          # optional decimals
    (?:[eE][+-]?\d+)?   # optional scientific notation
""", re.VERBOSE)

def clean_numeric(s):
    """Extract leading numeric, return float or NaN."""
    if pd.isna(s):
        return np.nan
    s = str(s).strip()
    m = num_regex.match(s)
    if not m:
        # handle ratio like "1.97 :1"
        ratio_match = re.match(r"^\s*([+-]?\d+(?:\.\d+)?)\s*:?\s*1\s*$", s)
        if ratio_match:
            return float(ratio_match.group(1))
        # pH like "5" or "5.6" already matched above; purely qualitative -> NaN
        return np.nan
    num = m.group(0)
    num = num.replace(",", "")
    try:
        return float(num)
    except:
        return np.nan

# canonical unit mapping (add as needed)
UNIT_MAP = {
    # molarity
    "mmol/l": "mmol/L",
    "μmol/l": "umol/L",
    "umol/l": "umol/L",
    # activity
    "iu/l": "IU/L",
    # mass concentration
    "mg/dl": "mg/dL",
    "g/dl":  "g/dL",
    "g/l":   "g/L",
    # osmolality
    "mosmol/kg": "mOsmol/kg",
    "mosm/kg":   "mOsmol/kg",
    "mosmolkg":  "mOsmol/kg",
}

def normalize_unit(raw_unit, col_name, raw_value_str):
    """Standardize unit text; handle special cases."""
    if raw_unit is None:
        raw_unit = ""
    unit = str(raw_unit)

    # grab substring after the numeric prefix
    if isinstance(raw_value_str, str):
        m = num_regex.match(raw_value_str.strip())
        if m:
            unit = raw_value_str[m.end():]
        else:
            # no number present -> qualitative?
            unit = raw_value_str

    # tidy punctuation/casing/spaces
    unit = unit.strip()
    unit = unit.replace(".", " ").replace("·", " ")
    unit = re.sub(r"\s+", " ", unit)
    unit = unit.replace(" /", "/").replace("/ ", "/")
    unit = unit.replace(" l", "/L").replace(" L", "/L")  # mild rescue
    unit = unit.lower()
    unit = unit.replace("µ", "u")  # normalize micro symbol
    unit = unit.replace("umol/ l", "umol/l")  # common spacing glitch

    # special cases by column
    if col_name.lower().startswith("ph"):
        return "unitless"
    if "ratio" in col_name.lower() or re.search(r"\d\s*:\s*1$", str(raw_value_str)):
        return "ratio"
    if unit in ("", " ", None):
        return "no_units"

    # strip leading junk like ":" or residual spaces
    unit = unit.strip(" :;")

    # collapse weird 'mg dL', 'mg  dL' forms -> mg/dL
    unit = unit.replace("mg dl", "mg/dl").replace("g dl", "g/dl")

    # map to canonical
    canon = UNIT_MAP.get(unit)
    if canon:
        return canon

    # heuristic rescues
    if "umol" in unit:
        return "umol/L"
    if "mmol" in unit:
        return "mmol/L"
    if "iu" in unit:
        return "IU/L"
    if "mg" in unit and "dl" in unit:
        return "mg/dL"
    if "g" in unit and "/l" in unit:
        return "g/L"
    if "osmol" in unit:
        return "mOsmol/kg"

    # qualitative?
    if re.fullmatch(r"(negative|pos|positive|trace|tr|nil|none)", unit.strip(), flags=re.I):
        return "qual"

    return unit  # leave as-is so we can audit later

def split_value_and_unit(s, col_name):
    """Return numeric_value, unit_label according to rules."""
    if pd.isna(s):
        return np.nan, "no_units"
    s = str(s).strip()
    val = clean_numeric(s)

    # classify unit
    unit = normalize_unit(None, col_name, s)

    # qualitative only (no number)
    if pd.isna(val):
        # If it looks like pH written as plain number-less? Rare; keep as qualitative.
        if unit == "unitless":
            return np.nan, "unitless"
        # e.g., "Negative"
        return np.nan, "qual" if unit not in ("no_units",) else "no_units"

    # have a numeric value
    if unit in ("", "no_units"):
        unit = "no_units"

    return val, unit

# Lets use the functions now on the biomarker columns
units_cols_added = []
for col in biomarker_cols:
    val_unit = df[col].apply(lambda x: split_value_and_unit(x, col))
    df[col] = val_unit.apply(lambda t: t[0])  # numeric only
    units_col = f"{col}_UNITS"
    df[units_col] = val_unit.apply(lambda t: t[1])
    units_cols_added.append(units_col)

    # move the units column right next to its value column
    cols = list(df.columns)
    cols.remove(units_col)
    insert_at = cols.index(col) + 1
    cols.insert(insert_at, units_col)
    df = df.reindex(columns=cols)

# --- 4) quick QC summary
summary = (
    pd.Series({c: (df[c] == "no_units").sum() for c in units_cols_added}, name="no_units_count")
    .to_frame()
)
summary["qual_count"] = pd.Series({c: (df[c] == "qual").sum() for c in units_cols_added})
summary["unique_units_seen"] = pd.Series({c: df[c].nunique() for c in units_cols_added})
print(summary.sort_values("no_units_count", ascending=False).head(15))

# --- 5) (optional) save
df.to_csv("META_updated_FINAL_COLOMBIA_UNITS_DIVIDED.csv", index=False)

